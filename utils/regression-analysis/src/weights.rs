// This file is part of Gear.

// Copyright (C) 2022 Gear Technologies Inc.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Autogenerated trait implementation for regression analysis tool
//!
//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
//! DATE: 2022-07-23
//! EXECUTION: Some(Native), WASM-EXECUTION: Compiled, CHAIN: Some("dev"), DB CACHE: 1024

// Executed Command:
// .\target\release\gear-node.exe benchmark pallet --steps 1 --repeat 1 --chain=dev --pallet=pallet_gear --extrinsic=* --execution=native --heap-pages=4096 --output .\utils\regression-analysis\src\weights.rs --template .\.maintain\regression-analysis-weight-template.rs.hbs

#![cfg_attr(rustfmt, rustfmt_skip)]

use pallet_gear::WeightInfo;
use frame_support::weights::Weight;
use sp_std::marker::PhantomData;
use crate::WEIGHTS_JSON;

/// Weights for pallet_gear using the runner.
pub struct BenchmarkWeight<T>(PhantomData<T>);

impl<T: frame_system::Config> WeightInfo for BenchmarkWeight<T> {
    fn initial_cost() -> Weight {
        pallet_gear::GearWeight::<T>::initial_cost()
    }
    fn allocation_cost() -> Weight {
        pallet_gear::GearWeight::<T>::allocation_cost()
    }
    fn grow_cost() -> Weight {
        pallet_gear::GearWeight::<T>::grow_cost()
    }
    fn load_cost() -> Weight {
        pallet_gear::GearWeight::<T>::load_cost()
    }
	fn claim_value_from_mailbox() -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["claim_value_from_mailbox"].calc_weight::<T>(components)
	}
	fn submit_code(c: u32, ) -> Weight {
        let components = [
            ("c", c as Weight),
        ].into();

        WEIGHTS_JSON["submit_code"].calc_weight::<T>(components)
	}
	fn submit_program(c: u32, s: u32, ) -> Weight {
        let components = [
            ("c", c as Weight),
            ("s", s as Weight),
        ].into();

        WEIGHTS_JSON["submit_program"].calc_weight::<T>(components)
	}
	fn send_message(p: u32, ) -> Weight {
        let components = [
            ("p", p as Weight),
        ].into();

        WEIGHTS_JSON["send_message"].calc_weight::<T>(components)
	}
	fn send_reply(p: u32, ) -> Weight {
        let components = [
            ("p", p as Weight),
        ].into();

        WEIGHTS_JSON["send_reply"].calc_weight::<T>(components)
	}
	fn initial_allocation(q: u32, ) -> Weight {
        let components = [
            ("q", q as Weight),
        ].into();

        WEIGHTS_JSON["initial_allocation"].calc_weight::<T>(components)
	}
	fn alloc_in_handle(q: u32, ) -> Weight {
        let components = [
            ("q", q as Weight),
        ].into();

        WEIGHTS_JSON["alloc_in_handle"].calc_weight::<T>(components)
	}
	fn reinstrument(c: u32, ) -> Weight {
        let components = [
            ("c", c as Weight),
        ].into();

        WEIGHTS_JSON["reinstrument"].calc_weight::<T>(components)
	}
	fn alloc(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["alloc"].calc_weight::<T>(components)
	}
	fn gas(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gas"].calc_weight::<T>(components)
	}
	fn gr_gas_available(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_gas_available"].calc_weight::<T>(components)
	}
	fn gr_msg_id(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_msg_id"].calc_weight::<T>(components)
	}
	fn gr_origin(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_origin"].calc_weight::<T>(components)
	}
	fn gr_program_id(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_program_id"].calc_weight::<T>(components)
	}
	fn gr_source(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_source"].calc_weight::<T>(components)
	}
	fn gr_value(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_value"].calc_weight::<T>(components)
	}
	fn gr_value_available(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_value_available"].calc_weight::<T>(components)
	}
	fn gr_size(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_size"].calc_weight::<T>(components)
	}
	fn gr_read(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_read"].calc_weight::<T>(components)
	}
	fn gr_read_per_kb(n: u32, ) -> Weight {
        let components = [
            ("n", n as Weight),
        ].into();

        WEIGHTS_JSON["gr_read_per_kb"].calc_weight::<T>(components)
	}
	fn gr_block_height(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_block_height"].calc_weight::<T>(components)
	}
	fn gr_block_timestamp(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_block_timestamp"].calc_weight::<T>(components)
	}
	fn gr_send_init(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_send_init"].calc_weight::<T>(components)
	}
	fn gr_send_push(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_send_push"].calc_weight::<T>(components)
	}
	fn gr_send_push_per_kb(n: u32, ) -> Weight {
        let components = [
            ("n", n as Weight),
        ].into();

        WEIGHTS_JSON["gr_send_push_per_kb"].calc_weight::<T>(components)
	}
	fn gr_send_commit(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_send_commit"].calc_weight::<T>(components)
	}
	fn gr_send_commit_per_kb(n: u32, ) -> Weight {
        let components = [
            ("n", n as Weight),
        ].into();

        WEIGHTS_JSON["gr_send_commit_per_kb"].calc_weight::<T>(components)
	}
	fn gr_reply_commit(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_reply_commit"].calc_weight::<T>(components)
	}
	fn gr_reply_commit_per_kb(n: u32, ) -> Weight {
        let components = [
            ("n", n as Weight),
        ].into();

        WEIGHTS_JSON["gr_reply_commit_per_kb"].calc_weight::<T>(components)
	}
	fn gr_reply_push(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_reply_push"].calc_weight::<T>(components)
	}
	fn gr_reply_push_per_kb(n: u32, ) -> Weight {
        let components = [
            ("n", n as Weight),
        ].into();

        WEIGHTS_JSON["gr_reply_push_per_kb"].calc_weight::<T>(components)
	}
	fn gr_reply_to(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_reply_to"].calc_weight::<T>(components)
	}
	fn gr_debug(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_debug"].calc_weight::<T>(components)
	}
	fn gr_exit_code(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_exit_code"].calc_weight::<T>(components)
	}
	fn gr_exit(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_exit"].calc_weight::<T>(components)
	}
	fn gr_leave(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_leave"].calc_weight::<T>(components)
	}
	fn gr_wait(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_wait"].calc_weight::<T>(components)
	}
	fn gr_wake(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_wake"].calc_weight::<T>(components)
	}
	fn gr_create_program_wgas(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["gr_create_program_wgas"].calc_weight::<T>(components)
	}
	fn gr_create_program_wgas_per_kb(n: u32, ) -> Weight {
        let components = [
            ("n", n as Weight),
        ].into();

        WEIGHTS_JSON["gr_create_program_wgas_per_kb"].calc_weight::<T>(components)
	}
	fn instr_i64const(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64const"].calc_weight::<T>(components)
	}
	fn instr_i64load(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64load"].calc_weight::<T>(components)
	}
	fn instr_i64store(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64store"].calc_weight::<T>(components)
	}
	fn instr_select(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_select"].calc_weight::<T>(components)
	}
	fn instr_if(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_if"].calc_weight::<T>(components)
	}
	fn instr_br(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_br"].calc_weight::<T>(components)
	}
	fn instr_br_if(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_br_if"].calc_weight::<T>(components)
	}
	fn instr_br_table(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_br_table"].calc_weight::<T>(components)
	}
	fn instr_br_table_per_entry(e: u32, ) -> Weight {
        let components = [
            ("e", e as Weight),
        ].into();

        WEIGHTS_JSON["instr_br_table_per_entry"].calc_weight::<T>(components)
	}
	fn instr_call(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_call"].calc_weight::<T>(components)
	}
	fn instr_call_indirect(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_call_indirect"].calc_weight::<T>(components)
	}
	fn instr_call_indirect_per_param(p: u32, ) -> Weight {
        let components = [
            ("p", p as Weight),
        ].into();

        WEIGHTS_JSON["instr_call_indirect_per_param"].calc_weight::<T>(components)
	}
	fn instr_local_get(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_local_get"].calc_weight::<T>(components)
	}
	fn instr_local_set(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_local_set"].calc_weight::<T>(components)
	}
	fn instr_local_tee(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_local_tee"].calc_weight::<T>(components)
	}
	fn instr_global_get(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_global_get"].calc_weight::<T>(components)
	}
	fn instr_global_set(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_global_set"].calc_weight::<T>(components)
	}
	fn instr_memory_current(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_memory_current"].calc_weight::<T>(components)
	}
	fn instr_i64clz(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64clz"].calc_weight::<T>(components)
	}
	fn instr_i64ctz(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64ctz"].calc_weight::<T>(components)
	}
	fn instr_i64popcnt(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64popcnt"].calc_weight::<T>(components)
	}
	fn instr_i64eqz(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64eqz"].calc_weight::<T>(components)
	}
	fn instr_i64extendsi32(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64extendsi32"].calc_weight::<T>(components)
	}
	fn instr_i64extendui32(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64extendui32"].calc_weight::<T>(components)
	}
	fn instr_i32wrapi64(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i32wrapi64"].calc_weight::<T>(components)
	}
	fn instr_i64eq(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64eq"].calc_weight::<T>(components)
	}
	fn instr_i64ne(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64ne"].calc_weight::<T>(components)
	}
	fn instr_i64lts(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64lts"].calc_weight::<T>(components)
	}
	fn instr_i64ltu(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64ltu"].calc_weight::<T>(components)
	}
	fn instr_i64gts(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64gts"].calc_weight::<T>(components)
	}
	fn instr_i64gtu(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64gtu"].calc_weight::<T>(components)
	}
	fn instr_i64les(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64les"].calc_weight::<T>(components)
	}
	fn instr_i64leu(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64leu"].calc_weight::<T>(components)
	}
	fn instr_i64ges(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64ges"].calc_weight::<T>(components)
	}
	fn instr_i64geu(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64geu"].calc_weight::<T>(components)
	}
	fn instr_i64add(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64add"].calc_weight::<T>(components)
	}
	fn instr_i64sub(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64sub"].calc_weight::<T>(components)
	}
	fn instr_i64mul(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64mul"].calc_weight::<T>(components)
	}
	fn instr_i64divs(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64divs"].calc_weight::<T>(components)
	}
	fn instr_i64divu(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64divu"].calc_weight::<T>(components)
	}
	fn instr_i64rems(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64rems"].calc_weight::<T>(components)
	}
	fn instr_i64remu(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64remu"].calc_weight::<T>(components)
	}
	fn instr_i64and(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64and"].calc_weight::<T>(components)
	}
	fn instr_i64or(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64or"].calc_weight::<T>(components)
	}
	fn instr_i64xor(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64xor"].calc_weight::<T>(components)
	}
	fn instr_i64shl(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64shl"].calc_weight::<T>(components)
	}
	fn instr_i64shrs(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64shrs"].calc_weight::<T>(components)
	}
	fn instr_i64shru(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64shru"].calc_weight::<T>(components)
	}
	fn instr_i64rotl(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64rotl"].calc_weight::<T>(components)
	}
	fn instr_i64rotr(r: u32, ) -> Weight {
        let components = [
            ("r", r as Weight),
        ].into();

        WEIGHTS_JSON["instr_i64rotr"].calc_weight::<T>(components)
	}
}
