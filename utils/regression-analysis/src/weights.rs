// This file is part of Gear.

// Copyright (C) 2022 Gear Technologies Inc.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Autogenerated trait implementation for regression analysis tool
//!
//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
//! DATE: 2022-07-22
//! EXECUTION: Some(Native), WASM-EXECUTION: Compiled, CHAIN: Some("dev"), DB CACHE: 1024

// Executed Command:
// .\target\release\gear-node.exe benchmark pallet --chain=dev --pallet=pallet_gear --extrinsic=* --execution=native --output .\utils\regression-analysis\src\weights.rs --template .\.maintain\regression-analysis-weight-template.rs.hbs

#![cfg_attr(rustfmt, rustfmt_skip)]

use pallet_gear::WeightInfo;
use frame_support::weights::Weight;
use sp_std::marker::PhantomData;
use crate::WEIGHTS_JSON;

/// Weights for pallet_gear using the runner.
pub struct BenchmarkWeight<T>(PhantomData<T>);

impl<T: frame_system::Config> WeightInfo for BenchmarkWeight<T> {
    fn initial_cost() -> Weight {
        pallet_gear::GearWeight::<T>::initial_cost()
    }
    fn allocation_cost() -> Weight {
        pallet_gear::GearWeight::<T>::allocation_cost()
    }
    fn grow_cost() -> Weight {
        pallet_gear::GearWeight::<T>::grow_cost()
    }
    fn load_cost() -> Weight {
        pallet_gear::GearWeight::<T>::load_cost()
    }
	fn submit_code(_c: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["submit_code"].calc_weight::<T>(components)
	}
	fn submit_program(c: u32, s: u32, ) -> Weight {
        let components = [
            ("c", c as Weight),
            ("s", s as Weight),
        ].into();

        WEIGHTS_JSON["submit_program"].calc_weight::<T>(components)
	}
	fn send_message(_p: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["send_message"].calc_weight::<T>(components)
	}
	fn send_reply(_p: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["send_reply"].calc_weight::<T>(components)
	}
	fn initial_allocation(_q: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["initial_allocation"].calc_weight::<T>(components)
	}
	fn alloc_in_handle(_q: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["alloc_in_handle"].calc_weight::<T>(components)
	}
	fn reinstrument(_c: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["reinstrument"].calc_weight::<T>(components)
	}
	fn alloc(_r: u32, ) -> Weight {
        let components = [
        ].into();

        dbg!(WEIGHTS_JSON["alloc"].calc_weight::<T>(components))
	}
	fn gas(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gas"].calc_weight::<T>(components)
	}
	fn gr_gas_available(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_gas_available"].calc_weight::<T>(components)
	}
	fn gr_msg_id(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_msg_id"].calc_weight::<T>(components)
	}
	fn gr_origin(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_origin"].calc_weight::<T>(components)
	}
	fn gr_program_id(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_program_id"].calc_weight::<T>(components)
	}
	fn gr_source(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_source"].calc_weight::<T>(components)
	}
	fn gr_value(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_value"].calc_weight::<T>(components)
	}
	fn gr_value_available(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_value_available"].calc_weight::<T>(components)
	}
	fn gr_size(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_size"].calc_weight::<T>(components)
	}
	fn gr_read(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_read"].calc_weight::<T>(components)
	}
	fn gr_read_per_kb(_n: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_read_per_kb"].calc_weight::<T>(components)
	}
	fn gr_block_height(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_block_height"].calc_weight::<T>(components)
	}
	fn gr_block_timestamp(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_block_timestamp"].calc_weight::<T>(components)
	}
	fn gr_send_init(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_send_init"].calc_weight::<T>(components)
	}
	fn gr_send_push(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_send_push"].calc_weight::<T>(components)
	}
	fn gr_send_push_per_kb(_n: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_send_push_per_kb"].calc_weight::<T>(components)
	}
	fn gr_send_commit(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_send_commit"].calc_weight::<T>(components)
	}
	fn gr_send_commit_per_kb(_n: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_send_commit_per_kb"].calc_weight::<T>(components)
	}
	fn gr_reply_commit(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_reply_commit"].calc_weight::<T>(components)
	}
	fn gr_reply_commit_per_kb(_n: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_reply_commit_per_kb"].calc_weight::<T>(components)
	}
	fn gr_reply_push(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_reply_push"].calc_weight::<T>(components)
	}
	fn gr_reply_push_per_kb(_n: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_reply_push_per_kb"].calc_weight::<T>(components)
	}
	fn gr_reply_to(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_reply_to"].calc_weight::<T>(components)
	}
	fn gr_debug(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_debug"].calc_weight::<T>(components)
	}
	fn gr_exit_code(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_exit_code"].calc_weight::<T>(components)
	}
	fn gr_exit(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_exit"].calc_weight::<T>(components)
	}
	fn gr_leave(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_leave"].calc_weight::<T>(components)
	}
	fn gr_wait(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_wait"].calc_weight::<T>(components)
	}
	fn gr_wake(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_wake"].calc_weight::<T>(components)
	}
	fn gr_create_program_wgas(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_create_program_wgas"].calc_weight::<T>(components)
	}
	fn gr_create_program_wgas_per_kb(_n: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["gr_create_program_wgas_per_kb"].calc_weight::<T>(components)
	}
	fn instr_i64const(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64const"].calc_weight::<T>(components)
	}
	fn instr_i64load(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64load"].calc_weight::<T>(components)
	}
	fn instr_i64store(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64store"].calc_weight::<T>(components)
	}
	fn instr_select(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_select"].calc_weight::<T>(components)
	}
	fn instr_if(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_if"].calc_weight::<T>(components)
	}
	fn instr_br(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_br"].calc_weight::<T>(components)
	}
	fn instr_br_if(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_br_if"].calc_weight::<T>(components)
	}
	fn instr_br_table(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_br_table"].calc_weight::<T>(components)
	}
	fn instr_br_table_per_entry(_e: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_br_table_per_entry"].calc_weight::<T>(components)
	}
	fn instr_call(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_call"].calc_weight::<T>(components)
	}
	fn instr_call_indirect(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_call_indirect"].calc_weight::<T>(components)
	}
	fn instr_call_indirect_per_param(_p: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_call_indirect_per_param"].calc_weight::<T>(components)
	}
	fn instr_local_get(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_local_get"].calc_weight::<T>(components)
	}
	fn instr_local_set(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_local_set"].calc_weight::<T>(components)
	}
	fn instr_local_tee(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_local_tee"].calc_weight::<T>(components)
	}
	fn instr_global_get(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_global_get"].calc_weight::<T>(components)
	}
	fn instr_global_set(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_global_set"].calc_weight::<T>(components)
	}
	fn instr_memory_current(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_memory_current"].calc_weight::<T>(components)
	}
	fn instr_i64clz(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64clz"].calc_weight::<T>(components)
	}
	fn instr_i64ctz(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64ctz"].calc_weight::<T>(components)
	}
	fn instr_i64popcnt(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64popcnt"].calc_weight::<T>(components)
	}
	fn instr_i64eqz(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64eqz"].calc_weight::<T>(components)
	}
	fn instr_i64extendsi32(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64extendsi32"].calc_weight::<T>(components)
	}
	fn instr_i64extendui32(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64extendui32"].calc_weight::<T>(components)
	}
	fn instr_i32wrapi64(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i32wrapi64"].calc_weight::<T>(components)
	}
	fn instr_i64eq(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64eq"].calc_weight::<T>(components)
	}
	fn instr_i64ne(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64ne"].calc_weight::<T>(components)
	}
	fn instr_i64lts(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64lts"].calc_weight::<T>(components)
	}
	fn instr_i64ltu(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64ltu"].calc_weight::<T>(components)
	}
	fn instr_i64gts(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64gts"].calc_weight::<T>(components)
	}
	fn instr_i64gtu(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64gtu"].calc_weight::<T>(components)
	}
	fn instr_i64les(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64les"].calc_weight::<T>(components)
	}
	fn instr_i64leu(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64leu"].calc_weight::<T>(components)
	}
	fn instr_i64ges(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64ges"].calc_weight::<T>(components)
	}
	fn instr_i64geu(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64geu"].calc_weight::<T>(components)
	}
	fn instr_i64add(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64add"].calc_weight::<T>(components)
	}
	fn instr_i64sub(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64sub"].calc_weight::<T>(components)
	}
	fn instr_i64mul(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64mul"].calc_weight::<T>(components)
	}
	fn instr_i64divs(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64divs"].calc_weight::<T>(components)
	}
	fn instr_i64divu(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64divu"].calc_weight::<T>(components)
	}
	fn instr_i64rems(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64rems"].calc_weight::<T>(components)
	}
	fn instr_i64remu(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64remu"].calc_weight::<T>(components)
	}
	fn instr_i64and(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64and"].calc_weight::<T>(components)
	}
	fn instr_i64or(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64or"].calc_weight::<T>(components)
	}
	fn instr_i64xor(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64xor"].calc_weight::<T>(components)
	}
	fn instr_i64shl(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64shl"].calc_weight::<T>(components)
	}
	fn instr_i64shrs(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64shrs"].calc_weight::<T>(components)
	}
	fn instr_i64shru(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64shru"].calc_weight::<T>(components)
	}
	fn instr_i64rotl(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64rotl"].calc_weight::<T>(components)
	}
	fn instr_i64rotr(_r: u32, ) -> Weight {
        let components = [
        ].into();

        WEIGHTS_JSON["instr_i64rotr"].calc_weight::<T>(components)
	}
}
